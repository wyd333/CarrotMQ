# CarrotMQ-消息队列

本项目为个人C/S项目，是一个基于Java语言编写的消息队列系统底层源码，实现并完善了消息队列MQ的业务功能。该项目通过Spring Boot构建，以SQLite为数据库，以MyBatis实现对持久层的管理。

### 核心功能：

**1.发布消息功能：**生产者将消息发送给对应的交换机，交换机再根据不同的转发规则转发给与之相绑定且符合规则的消息队列。

**2.订阅消息功能：**消费者去某个消息队列处注册，表明自己要从该消息队列中取消息。

**3.消费消息功能：**当消息队列中有消息时，自动向该消息队列的订阅消费者推送消息。

### 项目亮点：

从0到1编写消息队列源码，实现消息队列功能。如内存数据结构设计，模块划分，核心API的实现等，具体包括：

1.消息持久化。消息以文件的形式持久化至硬盘，当MQ启动时，可从硬盘上恢复数据至内存。

2.设计复制算法实现硬盘消息文件垃圾回收（GC）。

3.自实现Topic交换机转发规则bindingKey与routingKey验证算法。

4.多线程操作及线程安全问题考虑。

5.基于TCP，自定义应用层协议实现网络通信。

### 对比RabbitMQ，新增的功能点有：

**1.实现自动消息重试机制。**虽然RabbitMQ允许我们配置消息的重试策略，但是它没有内置的自动消息重试机制。CarrotMQ通过自定义的逻辑实现在消息处理失败时自动重试消息。

**2.内置的消息事务支持。**RabbitMQ提供了事务支持，但是这些事务是基于通道（channel）的，而不是基于消息的。CarrotMQ通过其它方案实现了多个消息之间执行的原子操作。

**3.消息流分析（仍在开发中）。**RabbitMQ没有内置的消息流分析功能，这可能会使在大规模消息系统中进行实时分析可能变得很复杂。虽然CarrotMQ暂时不会遇到大规模消息系统这样的体量，但CarrotMQ仍然希望进行尝试，增加内置的消息流分析功能来解决这个问题。

**4.消息轨迹追踪（仍在开发中）。**RabbitMQ没有内置的消息轨迹追踪功能，不便于在消息流中追踪和调试。CarrotMQ也希望在这方面进行尝试，在某些情况下可能会借助外部工具或服务来实现这样的功能。

下面对各个模块分点进行介绍。

## 一、简介消息队列与CarrotMQ

在线程安全的集合类中有阻塞队列（Blocking Queue）的概念。本质上阻塞队列就是一个**进程内部的生产者消费者模型**。而所谓的消息队列就是把阻塞队列这样的数据结构单独提取成了一个程序，进行独立的部署。因此可以理解为，消息队列是一个**进程和进程之间或服务和服务之间（比如分布式系统）的生产者消费模型**。

生产者消费者模型有**解耦合**和**削峰填谷**这两大好处：

1. 解耦合体现在，本来在分布式系统中，若A服务器直接调用B服务器（A给B发请求，B给A返回响应），那么A和B之间的耦合是比较大的；而引入了消息队列后，A把请求发送到消息队列，B再从消息队列获取到请求，有了消息队列这个“中间人”，降低了服务器A和服务器B之间的耦合。
2. 削峰填谷体现在，当A是入口服务器时，A需调用B完成⼀些具体的业务，如果A和B直接通信，那么当A突然收到用户请求的峰值时，B也会随之收到峰值，对B的性能造成了很大的挑战。而B作为处理业务的核心服务器，对稳定性的要求是非常高的。当引入消息队列后，A把请求发送到消息队列，B再从消息队列获取到请求，此时A虽然收到了很多请求，但会先传递给队列，这样一来B仍旧可以按照原来的节奏来处理请求，不至于一下子就遭受太大的并发量而崩溃造成更严重的后果。 

当然，消息队列也应用于异步处理和日志处理。

当今市面上也有一些知名的消息队列，如RabbitMQ，Kafka，RocketMQ，ActiveMQ等。本项目是以RabbitMQ为原型搭建的，为了与之对应，故取名为CarrotMQ。

**搭建CarrotMQ这个消息队列项目的初心是本人公司在实习过程中接触到了消息队列相关的业务，对此颇感兴趣，于是在了解过一些资料后尝试手动实现。CarrotMQ中既有RabbitMQ的影子，也有博主本人自己的理解。此外，该项目将长期迭代，功能也会不断地完善（如增加图形化操作界面和增加更多功能）。**

值得说明的是，该项目在搭建过程中，完全按照工程上软件开发的流程，包括需求分析，制定计划，编码实现，软件测试等阶段。其中格外重视软件测试这一过程，核心业务逻辑均经过测试用例设计并已通过单元测试和集成测试。

![](.\illustration3.png)

以下是对该结构图的简单介绍。

## 二、需求说明

CarrotMQ中涉及以下几个核心概念：

1.生产者（Producer） 。

2.消费者（Consumer） 。

3.中间人（Broker） 。

4.发布（Push），即生产者向中间人这里投递消息的过程。 

5.订阅（Subscribe） ，即记录了哪些消费者要从中间人这里取走数据。这个注册的过程称为“订阅” 。

6.消费 （Consume），即消费者从中间人这里取走数据的动作。

示意图1：一个生产者，一个消费者（见illustration1.png）

示意图2：N个生产者，N个消费者（见illustration2.png）

同时，Broker Server（作用是管理如何进出队列）内部也涉及一些关键概念：

1.虚拟主机（Virtual Host）。类似于MySQL中的database，是一个“逻辑”上的数据集合。 一个Broker Server上可以组织多种不同类别数据，可以使用Virtual Host做逻辑上的区分。 在实际开发中，一个Broker Server也可能同时用来管理多个业务线上的数据，也可以使用Virtual Host做逻辑上的区分。 

2.交换机（Exchange）。生产者把消息投递给Broker Server，实际上是把消息先交给了Broker Server上的交换机，再由交换机把消息交给对应的队列。CarrotMQ实现了三种交换机类型：

- Direct直接交换机：生产者发送消息时会指定⼀个“目标队列”的名字。交换机收到后，就在已绑定的队列里查找有无与之匹配的队列，如果有就转发过去（把消息塞进对应的队列中） ；如果没有，消息直接丢弃。
- Fanout 扇出交换机：会把消息放到交换机绑定的每个队列中，只要和这个交换机绑定任何队列都会转发消息。
- Topic 主题交换机： bindingKey，在把队列和交换机绑定的时候指定一个单词（类似于一个暗号）；routingKey，生产者发送消息的时候也指定一个单词。如果当前 bindingKey 和 routingKey 对上了，就可以把消息转发到对应的队列。

3.队列（Queue） 。真正用来存储处理消息的实体，后续消费者也是从对应的队列中取数据。 在一个大的消息队列中可以有很多具体的小队列。 

4.绑定（Binding）。即把交换机和队列之间建立关系，可以把交换机和队列视为数据库中多对多的关系。可以想象在MQ中也是有⼀个这样的中间表，所谓的“绑定”其实就是中间表中的一项。 

5.消息（Message）。具体指的是服务器A发给B的请求，以及服务器B给服务器A返回的响应。CarrotMQ中将一个消息视为一串二进制的数据。

## 三、Server核心API

消息队列服务器（Broker Server）提供的核心API有： 

1.创建队列（queueDeclare） 

2.销毁队列（queueDelete） 

3.创建交换机（exchangeDeclare） 

4.销毁交换机（exchageDelete） 

5.创建绑定（queueBind） 

6.解除绑定（queueUnbind） 

7.发布消息（basicPublish） 

8.订阅消息（basicConsume） 

9.确认消息（basicAck） 

## 四、持久化机制

上述的虚拟机、交换机、队列、绑定、消息等均需存储。

存储思路是内存和硬盘各存一份，且**内存为主，硬盘为辅**。

**在内存中存储的原因：** 对于MQ来说，转发处理数据的效率是非常关键的指标。使用内存来组织数据，效率会比在硬盘中高很多。

**在硬盘中存储原因：** 防止内存中数据因进程重启/主机重启而丢失。 

实现如下： 

1.交换机、队列、绑定：存储在数据库中 。

2.消息：存储在文件中。 

## 五、RPC通信

其他的服务器（生产者/消费者）需通过网络来与Broker Server进行交互。

CarrotMQ使用TCP + 自定义的应用层协议来实现生产者/消费者和BrokerServer之间的通信。

此处应用层协议主要工作就是让客户端可以通过网络调用Broker Server提供的编程接口。 因此，客户端这边也将提供上述的核心API，不过客户端的API中只是发送/接受响应，并不真正处理业务逻辑（处理逻辑在Server中）。此处以RPC的思想来实现。

客户端除了提供上述的核心API外，还需提供4个额外的方法以支撑其他工作： 

1. 创建 Connection 

2. 关闭 Connection
   - 此处用的是TCP连接。一个Connection对象就代表一个TCP连接。 

3. 创建 Channel 
   - 一个Connection里包含多个Channel，每个Channel上传输的数据都互不相干。
   - 在TCP中建立/断开⼀个连接成本是很高的，因此很多时候我们并不不希望频繁地建立/断开TCP连接，因此定义一个Channel，在不用的时候销毁 Channel。
   - 此处Channel是逻辑概念，比TCP轻量很多。 

4. 关闭 Channel 

## 六、消息应答模式

CarrotMQ实现了两种消息应答模式，分别是自动应答和手动应答。

1.自动应答，消费者把这个消息取走就算应答了。 

2.手动应答，basicAck 方法属于手动应答，消费者需要主动调用这个API来进行应答。



